# Зачем это?

Сразу возникает вопрос, почему ны не можем использовать `setInterval`,
ведь он также будет вызывать нашу функцию раз в определенный отрезок времени
и знаю частоту обновления кадров (обычно 60) мы можем просто написать что-то вроде:

```javascript
const FPS = 60;

const animate = () => {
	// Animate scene...
};

setInterval(animate, 1000 / FPS);
```

## Причин у этого несколько:
1. У разных пользователей разные экраны и на современных девайсах частота обновления часто превышает
60 герц.
2. Анимации, написанные таким образом будут проигрываться и в неактивных вкладках.
3. Браузер будет запускать функцию `animate` _примерно_ 60 раз в секунду, что приведет к тому,
что иногда придется запустить ререндер кадра после изменений, вызванных скриптом. Об этом подробнее.

## Процесс рендера
### setInterval
При использовании `setInterval` мы не знаем, в какой момент рендера кадра наш скрипт отработает,
из-за чего браузеру придется заново просчитывать предыдущие шаги, что может привести к потере кадров.
![](/images/request-animation-frame/render-process-0.jpg)

### requestAnimationFrame
`requestAnimationFrame` в свою очередь гарантирует нам, что наш скрипт запустится перед началом этих просчетов,
что помогает избежать повторения и улучшит производительность.
![](/images/request-animation-frame/render-process-1.jpg)
